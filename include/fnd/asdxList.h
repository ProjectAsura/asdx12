//-----------------------------------------------------------------------------
// File : asdxList.h
// Desc : Double-Linked List.
// Copyright(c) Project Asura. All right reserved.
//-----------------------------------------------------------------------------
#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <utility> // for std::swap


namespace asdx {

///////////////////////////////////////////////////////////////////////////////
// ListBase class
///////////////////////////////////////////////////////////////////////////////
class ListBase
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variable.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    ListBase() = default;

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~ListBase()
    { clear(); }

protected:
    ///////////////////////////////////////////////////////////////////////////
    // NodeBasel class
    ///////////////////////////////////////////////////////////////////////////
    class NodeBase
    {
        //=====================================================================
        // list of friend classed and methods.
        //=====================================================================
        friend class ListBase;
        template<typename T> friend class List;

    public:
        //=====================================================================
        // public variables.
        //=====================================================================
        /* NOTHING */

        //=====================================================================
        // public methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      コンストラクタです.
        //---------------------------------------------------------------------
        NodeBase()
        { m_Prev = m_Next = this; }
 
        //---------------------------------------------------------------------
        //! @brief      コピーコンストラクタです.
        //! 
        //! @param[in]      node        コピー元の値.
        //---------------------------------------------------------------------
        NodeBase(const NodeBase& node)
        : m_Next(node.m_Next)
        , m_Prev(node.m_Prev)
        { /* DO_NOTHING */ }

        //---------------------------------------------------------------------
        //! @brief      デストラクタです.
        //---------------------------------------------------------------------
        ~NodeBase()
        { unlink(); }

    private:
        //=====================================================================
        // private variables
        //=====================================================================
        NodeBase* m_Next = nullptr; //!< 次のノードへのポインタです.
        NodeBase* m_Prev = nullptr; //!< 前のノードへのポインタです.

        //=====================================================================
        // private methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      次のノードを持つかチェックします.
        //! 
        //! @retval true    次のノードを持ちます.
        //! @retval false   次のノードを持ちません.
        //---------------------------------------------------------------------
        bool has_next() const
        { return m_Next != this; }
        
        //---------------------------------------------------------------------
        //! @brief      前のノードを持つかチェックします.
        //! 
        //! @retval true    前のノードを持ちます.
        //! @retval false   前のノードを持ちません.
        //---------------------------------------------------------------------
        bool has_prev() const
        { return m_Prev != this; }
        
        //---------------------------------------------------------------------
        //! @brief      接続を持つかチェックします.
        //! 
        //! @retval true    接続を持ちます.
        //! @retval false   接続を持ちません.
        //---------------------------------------------------------------------
        bool has_link() const
        { return has_next() && has_prev(); }

        //---------------------------------------------------------------------
        //! @brief      接続を解除します.
        //---------------------------------------------------------------------
        void unlink()
        {
            link(m_Prev, m_Next);
            m_Prev = m_Next = this;
        }

        //---------------------------------------------------------------------
        //! @brief      2つのノードを接続します.
        //! 
        //! @param[in]      lhs     左側ノード.
        //! @param[in]      rhs     右側ノード.
        //---------------------------------------------------------------------
        static void link(NodeBase* lhs, NodeBase* rhs)
        {
            lhs->m_Next = rhs;
            rhs->m_Prev = lhs;
        }
    };

    //-------------------------------------------------------------------------
    //! @brief      リストをクリアします.
    //-------------------------------------------------------------------------
    void clear()
    { erase(begin(), end()); }

    //-------------------------------------------------------------------------
    //! @brief      先頭ノードを取得します.
    //! 
    //! @return     先頭ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* begin() const
    { return m_Tail.m_Next; }
    
    //-------------------------------------------------------------------------
    //! @brief      末端ノードを取得します.
    //! 
    //! @return     末端ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* end() const
    { return const_cast<NodeBase*>(&m_Tail); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用先頭ノードを取得します.
    //! 
    //! @return     逆巡回用先頭ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* rbegin() const
    { return m_Tail.m_Prev; }
    
    //-------------------------------------------------------------------------
    //! @brief      逆巡回用末端ノードを取得します.
    //! 
    //! @return     逆巡回用末端ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* rend() const
    { return const_cast<NodeBase*>(&m_Tail); }
    
    //-------------------------------------------------------------------------
    //! @brief      先頭ノードを取得します.
    //! 
    //! @return     先頭ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase& front() const
    { return *m_Tail.m_Next; }
    
    //-------------------------------------------------------------------------
    //! @brief      末端ノードを取得します.
    //! 
    //! @return     末端ノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase& back() const
    { return *m_Tail.m_Prev; }

    //-------------------------------------------------------------------------
    //! @brief      先頭に追加します.
    //! 
    //! @param[in]      node    追加するノード.
    //-------------------------------------------------------------------------
    void push_front(NodeBase* node)
    { insert(begin(), node); }
    
    //-------------------------------------------------------------------------
    //! @brief      末端に追加します.
    //! 
    //! @param[in]      node    追加するノード.
    //-------------------------------------------------------------------------
    void push_back(NodeBase* node)
    { insert(end(), node); }

    //-------------------------------------------------------------------------
    //! @brief      先頭ノードを取り出します.
    //-------------------------------------------------------------------------
    void pop_front()
    { erase(&front()); }
    
    //-------------------------------------------------------------------------
    //! @brief      末端ノードを取り出します.
    //-------------------------------------------------------------------------
    void pop_back()
    { erase(&back()); }

    //-------------------------------------------------------------------------
    //! @brief      リストが空かどうかチェックします.
    //! 
    //! @retval true    空ではありません.
    //! @retval fasle   空です.
    //-------------------------------------------------------------------------
    bool empty() const
    { return !m_Tail.has_link(); }

    //-------------------------------------------------------------------------
    //! @brief      指定したノードの前にノードを挿入します.
    //! 
    //! @param[in]      pos     挿入基準ノード.
    //! @param[in]      node    挿入するノード.
    //-------------------------------------------------------------------------
    void insert(NodeBase* pos, NodeBase* node)
    {
        if (pos == node)
        { return; }

        NodeBase::link(node->m_Prev, node->m_Next);
        NodeBase::link(pos->m_Prev, node);
        NodeBase::link(node, pos);
    }

    //-------------------------------------------------------------------------
    //! @brief      指定したノードの前にノード群を挿入します.
    //! 
    //! @param[in]      pos     挿入基準ノード.
    //! @param[in]      first   挿入するノード群の先頭.
    //! @param[in]      last    挿入するノード群の末端.
    //-------------------------------------------------------------------------
    void insert(NodeBase* pos, NodeBase* first, NodeBase* last)
    {
        if (first == last)
        { return; }

        auto back = last->m_Prev;
        NodeBase::link(first->m_Prev, last);
        NodeBase::link(pos->m_Prev, first);
        NodeBase::link(back, pos);
    }

    //-------------------------------------------------------------------------
    //! @brief      指定されたノードを削除します.
    //! 
    //! @param[in]      node    削除するノード.
    //! @return     削除ノードが持つ次のノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* erase(NodeBase* node)
    {
        auto next = node->m_Next;
        node->unlink();
        return next;
    }

    //-------------------------------------------------------------------------
    //! @brief      指定されたノード群を削除します.
    //! 
    //! @param[in]      first   削除対象の先頭ノード.
    //! @param[in]      last    削除対象の末端ノード.
    //! @return     削除対象の末端ノードが持つ次のノードを返却します.
    //-------------------------------------------------------------------------
    NodeBase* erase(NodeBase* first, NodeBase* last)
    {
        auto back = last->m_Prev;
        NodeBase::link(first->m_Prev, last);
        NodeBase::link(back, first);
        return last;
    }

    //-------------------------------------------------------------------------
    //! @brief      保持するノードを数を取得します.
    //! 
    //! @return     保持するノード数を返却します.
    //! @note       カウントアップ処理を行うため低速なので注意してください.
    //-------------------------------------------------------------------------
    size_t size() const 
    {
        size_t count = 0;
        for(auto itr = begin(); itr != end(); itr = itr->m_Next)
        { count++; }
        return count;
    }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    NodeBase m_Tail = {};

    //=========================================================================
    // private methods.
    //=========================================================================
    /* NOTHING */
};

///////////////////////////////////////////////////////////////////////////////
// List class
///////////////////////////////////////////////////////////////////////////////
template<typename T>
class List : public ListBase
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    ///////////////////////////////////////////////////////////////////////////
    // Node class
    ///////////////////////////////////////////////////////////////////////////
    class Node : public ListBase::NodeBase
    {
        //=====================================================================
        // list of friend classes and methods.
        //=====================================================================
        friend class List<T>;

    public:
        //=====================================================================
        // public variables.
        //=====================================================================
        /* NOTHING */

        //=====================================================================
        // public methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      コンストラクタです.
        //---------------------------------------------------------------------
        Node()
        : ListBase::NodeBase()
        , m_Derived(static_cast<T*>(this))
        { /* DO_NOTHING */ }

    private:
        //=====================================================================
        // private variables.
        //=====================================================================
        T* m_Derived = nullptr;    //!< 派生型ポインタ.

        //=====================================================================
        // private methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      派生型ポインタを取得します.
        //! 
        //! @return     派生型ポインタを返却します.
        //---------------------------------------------------------------------
        T* derive_ptr() const
        { return m_Derived; }
        
        //---------------------------------------------------------------------
        //! @brief      派生型参照を取得します.
        //! 
        //! @return     派生型参照を返却します.
        //---------------------------------------------------------------------
        T& derive_ref() const
        { return *m_Derived; }
    };

    ///////////////////////////////////////////////////////////////////////////
    // Iterator class
    ///////////////////////////////////////////////////////////////////////////
    template<typename DataType, typename NodeType>
    class Iterator
    {
        //=====================================================================
        // list of friend classes and methods.
        //=====================================================================
        friend class List;

    public:
        //=====================================================================
        // public variables.
        //=====================================================================
        /* NOTHING */

        //=====================================================================
        // public methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      引数付きコンストラクタです.
        //! 
        //! @param[in]      node        リストノードです.
        //---------------------------------------------------------------------
        Iterator(NodeType* node)
        : m_Node(node)
        { /* DO_NOTHING */ }

        //---------------------------------------------------------------------
        //! @brief      アロー演算子です.
        //---------------------------------------------------------------------
        DataType* operator-> () const
        { return List::data_ptr(m_Node); }

        //---------------------------------------------------------------------
        //! @brief      関節参照演算子です.
        //---------------------------------------------------------------------
        DataType& operator* () const
        { return List::data_ref(m_Node); }
        
        //---------------------------------------------------------------------
        //! @brief      前置インクリメントです.
        //---------------------------------------------------------------------
        Iterator& operator++ ()
        {
            m_Node = List::next(m_Node);
            return *this;
        }

        //---------------------------------------------------------------------
        //! @brief      前置デクリメントです.
        //---------------------------------------------------------------------
        Iterator& operator-- ()
        {
            m_Node = List::prev(m_Node);
            return *this;
        }

        //---------------------------------------------------------------------
        //! @brief      後置インクリメントです.
        //---------------------------------------------------------------------
        Iterator operator++(int)
        {
            auto result = *this;
            m_Node = List::next(m_Node);
            return result;
        }
        
        //---------------------------------------------------------------------
        //! @brief      後置デクリメントです.
        //---------------------------------------------------------------------
        Iterator operator--(int)
        {
            auto result = *this;
            m_Node = List::prev(m_Node);
            return result;
        }

        //---------------------------------------------------------------------
        //! @brief      等価比較演算子です.
        //! 
        //! @param[in]      itr     比較する値.
        //! @retval true    等価です.
        //! @retval false   非等価です.
        //---------------------------------------------------------------------
        bool operator== (const Iterator& itr) const
        { return m_Node == itr.m_Node; }
        
        //---------------------------------------------------------------------
        //! @brief      非等価比較演算子です.
        //! 
        //! @param[in]      itr     比較する値.
        //! @retval true    非等価です.
        //! @retval false   等価です.
        //---------------------------------------------------------------------
        bool operator!= (const Iterator& itr) const
        { return m_Node != itr.m_Node; }

    private:
        //=====================================================================
        // private variables.
        //=====================================================================
        NodeType* m_Node = nullptr; //!< リストノードです.

        //=====================================================================
        // private methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      引数付きコンストラクタです.
        //! 
        //! @param[in]      node        リストノード.
        //---------------------------------------------------------------------
        Iterator(ListBase::NodeBase* node) 
        : m_Node(static_cast<NodeType*>(node))
        { /* DO_NOTHING */ }
    };

    ///////////////////////////////////////////////////////////////////////////
    // ReverseIterator class
    ///////////////////////////////////////////////////////////////////////////
    template<typename DataType, typename NodeType>
    class ReverseIterator
    {
        //=====================================================================
        // list of friend classes and methods.
        //=====================================================================
        friend class List;

    public:
        //=====================================================================
        // public variables.
        //=====================================================================
        /* NOTHING */

        //=====================================================================
        // public methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      引数付きコンストラクタです.
        //! 
        //! @param[in]      node        リストノードです.
        //---------------------------------------------------------------------
        ReverseIterator(NodeType* node)
        : m_Node(node)
        { /* DO_NOTHING */ }

        //---------------------------------------------------------------------
        //! @brief      アロー演算子です.
        //---------------------------------------------------------------------
        DataType* operator-> () const
        { return List::data_ptr(m_Node); }

        //---------------------------------------------------------------------
        //! @brief      関節参照演算子です.
        //---------------------------------------------------------------------
        DataType& operator* () const
        { return List::data_ref(m_Node); }
        
        //---------------------------------------------------------------------
        //! @brief      前置インクリメントです.
        //---------------------------------------------------------------------
        ReverseIterator& operator++ ()
        {
            m_Node = List::prev(m_Node);
            return *this;
        }

        //---------------------------------------------------------------------
        //! @brief      前置デクリメントです.
        //---------------------------------------------------------------------
        ReverseIterator& operator-- ()
        { 
            m_Node = List::next(m_Node);
            return *this;
        }

        //---------------------------------------------------------------------
        //! @brief      後置インクリメントです.
        //---------------------------------------------------------------------
        ReverseIterator operator++ (int)
        {
            auto result = *this;
            m_Node = List::prev(m_Node);
            return result;
        }

        //---------------------------------------------------------------------
        //! @brief      後置デクリメントです.
        //---------------------------------------------------------------------
        ReverseIterator operator-- (int)
        {
            auto result = *this;
            m_Node = List::next(m_Node);
            return result;
        }

        //---------------------------------------------------------------------
        //! @brief      等価比較演算子です.
        //! 
        //! @param[in]      itr     比較する値.
        //! @retval true    等価です.
        //! @retval false   非等価です.
        //---------------------------------------------------------------------
        bool operator== (const ReverseIterator& itr) const
        { return m_Node == itr.m_Node; }
        
        //---------------------------------------------------------------------
        //! @brief      非等価比較演算子です.
        //! 
        //! @param[in]      itr     比較する値.
        //! @retval true    非等価です.
        //! @retval false   等価です.
        //---------------------------------------------------------------------
        bool operator!= (const ReverseIterator& itr) const
        { return m_Node != itr.m_Node; }

    private:
        //=====================================================================
        // private variables.
        //=====================================================================
        NodeType* m_Node = nullptr;     //!< リストノードです.

        //=====================================================================
        // private methods.
        //=====================================================================

        //---------------------------------------------------------------------
        //! @brief      引数付きコンストラクタです.
        //! 
        //! @param[in]      node        リストノードです.
        //---------------------------------------------------------------------
        ReverseIterator(ListBase::NodeBase* node) 
        : m_Node(static_cast<NodeType*>(node))
        { /* DO_NOTHING */ }
    };

    //=========================================================================
    // Type Definitions.
    //=========================================================================
    typedef Iterator<T, Node>                       iterator;
    typedef Iterator<const T, const Node>           const_iterator;
    typedef ReverseIterator<T, Node>                reverse_iterator;
    typedef ReverseIterator<const T, const Node>    const_reverse_iterator;

    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    List()
    : ListBase()
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~List()
    { clear(); }

    //-------------------------------------------------------------------------
    //! @brief      先頭イテレータを取得します.
    //! 
    //! @return     先頭イテレータを返却します.
    //-------------------------------------------------------------------------
    iterator begin()
    { return ListBase::begin(); }

    //-------------------------------------------------------------------------
    //! @brief      先頭イテレータを取得します.
    //! 
    //! @return     先頭イテレータを返却します.
    //-------------------------------------------------------------------------
    const_iterator begin() const
    { return ListBase::begin(); }

    //-------------------------------------------------------------------------
    //! @brief      先頭コンストイテレータを取得します.
    //! 
    //! @return     先頭コンストイテレータを返却します.
    //-------------------------------------------------------------------------
    const_iterator cbegin() const
    { return ListBase::begin(); }

    //-------------------------------------------------------------------------
    //! @brief      末端イテレータを取得します.
    //! 
    //! @return     末端イテレータを返却します.
    //-------------------------------------------------------------------------
    iterator end()
    { return ListBase::end(); }

    //-------------------------------------------------------------------------
    //! @brief      末端イテレータを取得します.
    //! 
    //! @return     末端イテレータを返却します.
    //-------------------------------------------------------------------------
    const_iterator end() const
    { return ListBase::end(); }

    //-------------------------------------------------------------------------
    //! @brief      末端コンストイテレータを取得します.
    //! 
    //! @return     末端コンストイテレータを返却します.
    //-------------------------------------------------------------------------
    const_iterator cend() const
    { return ListBase::end(); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の先頭イテレータを取得します.
    //! 
    //! @return     逆巡回用の先頭イテレータを返却します.
    //-------------------------------------------------------------------------
    reverse_iterator rbegin()
    { return ListBase::rbegin(); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の先頭イテレータを取得します.
    //! 
    //! @return     逆巡回用の先頭イテレータを返却します.
    //-------------------------------------------------------------------------
    const_reverse_iterator rbegin() const
    { return ListBase::rbegin(); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の先頭コンストイテレータを取得します.
    //! 
    //! @return     逆巡回用の先頭コンストイテレータを返却します.
    //-------------------------------------------------------------------------
    const_reverse_iterator crbegin() const
    { return ListBase::rbegin(); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の末端イテレータを取得します.
    //! 
    //! @return     逆巡回用の末端イテレータを返却します,
    //-------------------------------------------------------------------------
    reverse_iterator rend()
    { return ListBase::rend(); }

    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の末端イテレータを取得します.
    //! 
    //! @return     逆巡回用の末端イテレータを返却します.
    //-------------------------------------------------------------------------
    const_reverse_iterator rend() const
    { return ListBase::rend(); }
 
    //-------------------------------------------------------------------------
    //! @brief      逆巡回用の末端コンストイテレータを取得します.
    //! 
    //! @return     逆巡回用の末端コンストイテレータを返却します.
    //-------------------------------------------------------------------------
    const_reverse_iterator crend() const
    { return ListBase::rend(); }

    //-------------------------------------------------------------------------
    //! @brief      先頭要素を取得します.
    //! 
    //! @return     先頭要素を返却します.
    //-------------------------------------------------------------------------
    T& front()
    { return data_ref(static_cast<Node&>(ListBase::front())); }

    //-------------------------------------------------------------------------
    //! @brief      末端要素を取得します.
    //! 
    //! @return     末端要素を返却します.
    //-------------------------------------------------------------------------
    T& back ()
    { return data_ref(static_cast<Node&>(ListBase::back())); }

    //-------------------------------------------------------------------------
    //! @brief      先頭に追加します.
    //! 
    //! @param[in]      node        追加するノード.
    //-------------------------------------------------------------------------
    void push_front(Node* node)
    { ListBase::push_front(node); }

    //-------------------------------------------------------------------------
    //! @brief      末尾に追加します.
    //! 
    //! @param[in]      node        追加するノード.
    //-------------------------------------------------------------------------
    void push_back (Node* node)
    { ListBase::push_back(node); }

    //-------------------------------------------------------------------------
    //! @brief      指定ノードの前に挿入します.
    //! 
    //! @param[in]      pos     挿入基準ノード.
    //! @param[in]      node    挿入するノード.
    //-------------------------------------------------------------------------
    void insert(iterator pos, Node* node)
    { ListBase::insert(pos.m_Node, node); }

    //-------------------------------------------------------------------------
    //! @brief      指定ノードの前にノード群を挿入します.
    //! 
    //! @param[in]      pos     挿入基準ノード.
    //! @param[in]      first   挿入するノード群の先頭.
    //! @param[in]      last    挿入するノード群の末尾.
    //-------------------------------------------------------------------------
    void insert(iterator pos, iterator first, iterator last)
    { ListBase::insert(pos.m_Node, first.m_Node, last.m_Node); }

    //-------------------------------------------------------------------------
    //! @brief      指定ノードを削除します.
    //! 
    //! @param[in]      pos     削除するノード.
    //-------------------------------------------------------------------------
    iterator erase(iterator pos)
    { return ListBase::erase(pos.m_Node); }

    //-------------------------------------------------------------------------
    //! @brief      指定ノード群を削除します.
    //! 
    //! @param[in]      first   削除するノード群の先頭.
    //! @param[in]      last    削除するノード群の末尾.
    //-------------------------------------------------------------------------
    iterator erase(iterator first, iterator last)
    { return ListBase::erase(first.m_Node, last.m_Node); }

    //-------------------------------------------------------------------------
    //! @brief      小さい順に並び変えを行います.
    //-------------------------------------------------------------------------
    void sort() 
    { sort(begin(), end(), std::less<T>()); }

    //-------------------------------------------------------------------------
    //! @brief      指定範囲を小さい順に並び変えを行います.
    //! 
    //! @param[in]      first       範囲先頭.
    //! @param[in]      last        範囲末尾.
    //-------------------------------------------------------------------------
    void sort(iterator first, iterator last) 
    { sort(first, last, std::less<T>()); }

    //-------------------------------------------------------------------------
    //! @brief      比較方法を指定して並び変えます.
    //! 
    //! @param[in]      compare     比較関数.
    //-------------------------------------------------------------------------
    template<typename Comparer>
    void sort(Comparer compare) 
    { sort(begin(), end(), compare); }

    //-------------------------------------------------------------------------
    //! @brief      並び替えを行います.
    //! 
    //! @param[in]      first       範囲先頭
    //! @param[in]      last        範囲末尾.
    //! @param[in]      compare     比較関数.
    //-------------------------------------------------------------------------
    template<typename Comparer>
    void sort(iterator first, iterator last, Comparer compare) 
    { comb_sort11(first, last, compare); }

    //-------------------------------------------------------------------------
    //! @brief      指定されたアクションを全要素に対して実行します.
    //! 
    //! @param[in]      action      実行処理関数.
    //-------------------------------------------------------------------------
    template<typename Action>
    void foreach(Action action)
    {
        for(auto itr = begin(); itr != end(); ++itr)
        { action(*itr); }
    }

    //-------------------------------------------------------------------------
    //! @brief      指定されたアクションを逆順番で全要素に対して実行します.
    //! 
    //! @param[in]      action      実行処理関数.
    //-------------------------------------------------------------------------
    template<typename Action>
    void reverse_foreach(Action action)
    {
        for(auto itr = rbegin(); itr != rend(); ++itr)
        { action(*itr); }
    }

    // 基底クラスの関数をそのまま流用.
    using ListBase::clear;
    using ListBase::pop_front;
    using ListBase::pop_back;
    using ListBase::empty;
    using ListBase::size;

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // private methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      データ型参照を取得します.
    //! 
    //! @param[in]      node        ノード.
    //! @return     データ型参照を返却します.
    //-------------------------------------------------------------------------
    static T& data_ref(const Node& node)
    { return node.derive_ref(); }

    //-------------------------------------------------------------------------
    //! @brief      データ型参照を取得します.
    //! 
    //! @param[in]      node        ノード.
    //! @return     データ参照を返却します.
    //-------------------------------------------------------------------------
    static T& data_ref(const Node* node)
    { return node->derive_ref(); }

    //-------------------------------------------------------------------------
    //! @brief      データ型ポインタを取得します.
    //! 
    //! @param[in]      node        ノード.
    //! @retrn      データ型ポインタを返却します.
    //-------------------------------------------------------------------------
    static T* data_ptr(const Node* node)
    { return node->derive_ptr(); }

    //-------------------------------------------------------------------------
    //! @brief      次のノードを取得します.
    //! 
    //! @param[in]      node        ノード.
    //! @return     次のノードを返却します.
    //-------------------------------------------------------------------------
    static Node* next(const Node* node)
    { return static_cast<Node*>(node->m_Next); }

    //-------------------------------------------------------------------------
    //! @brief      前のノードを取得します.
    //! 
    //! @param[in]      node        ノード.
    //! @return     前のノードを返却します.
    //-------------------------------------------------------------------------
    static Node* prev(const Node* node)
    { return static_cast<Node*>(node->m_Prev); }

    //-------------------------------------------------------------------------
    //! @brief      イテレータを指定回数分インクリメントします.
    //! 
    //! @param[in]      itr     イテレータ.
    //! @param[in]      count   進める数.
    //! @return     指定回数分だけインクリメントしたイテレータを返却します.
    //-------------------------------------------------------------------------
    static iterator advance(iterator itr, size_t count)
    {
        for(; count !=0; ++itr)
        { --count; }
        return itr;
    }

    //-------------------------------------------------------------------------
    //! @brief      イテレータ間の距離を求めます.
    //! 
    //! @param[in]      first       開始イテレータ位置.
    //! @param[in]      last        終了イテレータ位置.
    //! @preturn    イテレータ間の距離を返却します.
    //-------------------------------------------------------------------------
    static size_t distance(iterator first, iterator last)
    {
        size_t dist = 0;
        for(auto itr = first; itr != last; ++itr)
        { ++dist; }
        return dist;
    }

    //-------------------------------------------------------------------------
    //! @brief      改良コムソートを実行します.
    //! 
    //! @param[in]      first       範囲先頭.
    //! @param[in]      last        範囲末尾.
    //! @param[in]      compare     比較関数.
    //-------------------------------------------------------------------------
    template<typename Comparer>
    void comb_sort11(iterator first, iterator last, Comparer compare)
    {
        auto gap  = distance(first, last);
        auto done = false;

        while(!done || gap > 1)
        {
            gap = gap * 10 / 13;

            if (gap == 0)
            { gap = 1; }
            else if (gap == 9 || gap == 10)
            { gap = 11; }

            done = true;

            auto lhs = first;
            auto rhs = advance(first, gap);
            for(; rhs != last; ++lhs, ++rhs)
            {
                if (compare(*lhs, *rhs))
                    continue;

                // 条件を満たさない場合は入れ替える.
                auto tmp = advance(rhs, 1);
                insert(lhs, &(*rhs));
                insert(tmp, &(*lhs));
                std::swap(lhs, rhs);
                
                done = false;
            }
        }
    }
};

} // namespace asdx
