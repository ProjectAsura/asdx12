// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BASE_ASDX_RES_H_
#define FLATBUFFERS_GENERATED_BASE_ASDX_RES_H_

#include "flatbuffers/flatbuffers.h"

namespace asdx {
namespace res {

struct Half2;

struct Half3;

struct Half4;

struct Float2;

struct Float3;

struct Float4;

struct BoundingSphere;

struct BoundingBox;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Half2 FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t X_;
  uint16_t Y_;

 public:
  Half2()
      : X_(0),
        Y_(0) {
  }
  Half2(uint16_t _X, uint16_t _Y)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)) {
  }
  uint16_t X() const {
    return flatbuffers::EndianScalar(X_);
  }
  uint16_t Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
};
FLATBUFFERS_STRUCT_END(Half2, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Half3 FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t X_;
  uint16_t Y_;
  uint16_t Z_;

 public:
  Half3()
      : X_(0),
        Y_(0),
        Z_(0) {
  }
  Half3(uint16_t _X, uint16_t _Y, uint16_t _Z)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)),
        Z_(flatbuffers::EndianScalar(_Z)) {
  }
  uint16_t X() const {
    return flatbuffers::EndianScalar(X_);
  }
  uint16_t Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
  uint16_t Z() const {
    return flatbuffers::EndianScalar(Z_);
  }
};
FLATBUFFERS_STRUCT_END(Half3, 6);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Half4 FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t X_;
  uint16_t Y_;
  uint16_t Z_;
  uint16_t W_;

 public:
  Half4()
      : X_(0),
        Y_(0),
        Z_(0),
        W_(0) {
  }
  Half4(uint16_t _X, uint16_t _Y, uint16_t _Z, uint16_t _W)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)),
        Z_(flatbuffers::EndianScalar(_Z)),
        W_(flatbuffers::EndianScalar(_W)) {
  }
  uint16_t X() const {
    return flatbuffers::EndianScalar(X_);
  }
  uint16_t Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
  uint16_t Z() const {
    return flatbuffers::EndianScalar(Z_);
  }
  uint16_t W() const {
    return flatbuffers::EndianScalar(W_);
  }
};
FLATBUFFERS_STRUCT_END(Half4, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float2 FLATBUFFERS_FINAL_CLASS {
 private:
  float X_;
  float Y_;

 public:
  Float2()
      : X_(0),
        Y_(0) {
  }
  Float2(float _X, float _Y)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)) {
  }
  float X() const {
    return flatbuffers::EndianScalar(X_);
  }
  float Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
};
FLATBUFFERS_STRUCT_END(Float2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float3 FLATBUFFERS_FINAL_CLASS {
 private:
  float X_;
  float Y_;
  float Z_;

 public:
  Float3()
      : X_(0),
        Y_(0),
        Z_(0) {
  }
  Float3(float _X, float _Y, float _Z)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)),
        Z_(flatbuffers::EndianScalar(_Z)) {
  }
  float X() const {
    return flatbuffers::EndianScalar(X_);
  }
  float Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
  float Z() const {
    return flatbuffers::EndianScalar(Z_);
  }
};
FLATBUFFERS_STRUCT_END(Float3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float4 FLATBUFFERS_FINAL_CLASS {
 private:
  float X_;
  float Y_;
  float Z_;
  float W_;

 public:
  Float4()
      : X_(0),
        Y_(0),
        Z_(0),
        W_(0) {
  }
  Float4(float _X, float _Y, float _Z, float _W)
      : X_(flatbuffers::EndianScalar(_X)),
        Y_(flatbuffers::EndianScalar(_Y)),
        Z_(flatbuffers::EndianScalar(_Z)),
        W_(flatbuffers::EndianScalar(_W)) {
  }
  float X() const {
    return flatbuffers::EndianScalar(X_);
  }
  float Y() const {
    return flatbuffers::EndianScalar(Y_);
  }
  float Z() const {
    return flatbuffers::EndianScalar(Z_);
  }
  float W() const {
    return flatbuffers::EndianScalar(W_);
  }
};
FLATBUFFERS_STRUCT_END(Float4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoundingSphere FLATBUFFERS_FINAL_CLASS {
 private:
  asdx::res::Float3 Center_;
  float Radius_;

 public:
  BoundingSphere()
      : Center_(),
        Radius_(0) {
  }
  BoundingSphere(const asdx::res::Float3 &_Center, float _Radius)
      : Center_(_Center),
        Radius_(flatbuffers::EndianScalar(_Radius)) {
  }
  const asdx::res::Float3 &Center() const {
    return Center_;
  }
  float Radius() const {
    return flatbuffers::EndianScalar(Radius_);
  }
};
FLATBUFFERS_STRUCT_END(BoundingSphere, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoundingBox FLATBUFFERS_FINAL_CLASS {
 private:
  asdx::res::Float3 Mini_;
  asdx::res::Float3 Maxi_;

 public:
  BoundingBox()
      : Mini_(),
        Maxi_() {
  }
  BoundingBox(const asdx::res::Float3 &_Mini, const asdx::res::Float3 &_Maxi)
      : Mini_(_Mini),
        Maxi_(_Maxi) {
  }
  const asdx::res::Float3 &Mini() const {
    return Mini_;
  }
  const asdx::res::Float3 &Maxi() const {
    return Maxi_;
  }
};
FLATBUFFERS_STRUCT_END(BoundingBox, 24);

}  // namespace res
}  // namespace asdx

#endif  // FLATBUFFERS_GENERATED_BASE_ASDX_RES_H_
