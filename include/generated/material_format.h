// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATERIAL_ASDX_RES_H_
#define FLATBUFFERS_GENERATED_MATERIAL_ASDX_RES_H_

#include "flatbuffers/flatbuffers.h"

#include "base_format.h"

namespace asdx {
namespace res {

struct MaterialParameter;
struct MaterialParameterBuilder;

struct Material;
struct MaterialBuilder;

struct MaterialSet;
struct MaterialSetBuilder;

struct MaterialParameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t Offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t Size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct MaterialParameterBuilder {
  typedef MaterialParameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(MaterialParameter::VT_NAME, Name);
  }
  void add_Offset(uint32_t Offset) {
    fbb_.AddElement<uint32_t>(MaterialParameter::VT_OFFSET, Offset, 0);
  }
  void add_Size(uint32_t Size) {
    fbb_.AddElement<uint32_t>(MaterialParameter::VT_SIZE, Size, 0);
  }
  explicit MaterialParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialParameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialParameter> CreateMaterialParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    uint32_t Offset = 0,
    uint32_t Size = 0) {
  MaterialParameterBuilder builder_(_fbb);
  builder_.add_Size(Size);
  builder_.add_Offset(Offset);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialParameter> CreateMaterialParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    uint32_t Offset = 0,
    uint32_t Size = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return asdx::res::CreateMaterialParameter(
      _fbb,
      Name__,
      Offset,
      Size);
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BASECOLOR = 6,
    VT_ORM = 8,
    VT_NORMAL = 10,
    VT_EMISSIVE = 12,
    VT_USERDATA = 14,
    VT_PARAMETERS = 16,
    VT_BUFFER = 18,
    VT_HASALPHA = 20,
    VT_TRANSPARENT = 22
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t BaseColor() const {
    return GetField<uint32_t>(VT_BASECOLOR, 0);
  }
  uint32_t Orm() const {
    return GetField<uint32_t>(VT_ORM, 0);
  }
  uint32_t Normal() const {
    return GetField<uint32_t>(VT_NORMAL, 0);
  }
  uint32_t Emissive() const {
    return GetField<uint32_t>(VT_EMISSIVE, 0);
  }
  const flatbuffers::Vector<uint32_t> *UserData() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_USERDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<asdx::res::MaterialParameter>> *Parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<asdx::res::MaterialParameter>> *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<uint8_t> *Buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool HasAlpha() const {
    return GetField<uint8_t>(VT_HASALPHA, 0) != 0;
  }
  bool Transparent() const {
    return GetField<uint8_t>(VT_TRANSPARENT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<uint32_t>(verifier, VT_BASECOLOR) &&
           VerifyField<uint32_t>(verifier, VT_ORM) &&
           VerifyField<uint32_t>(verifier, VT_NORMAL) &&
           VerifyField<uint32_t>(verifier, VT_EMISSIVE) &&
           VerifyOffset(verifier, VT_USERDATA) &&
           verifier.VerifyVector(UserData()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(Parameters()) &&
           verifier.VerifyVectorOfTables(Parameters()) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(Buffer()) &&
           VerifyField<uint8_t>(verifier, VT_HASALPHA) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPARENT) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(Material::VT_NAME, Name);
  }
  void add_BaseColor(uint32_t BaseColor) {
    fbb_.AddElement<uint32_t>(Material::VT_BASECOLOR, BaseColor, 0);
  }
  void add_Orm(uint32_t Orm) {
    fbb_.AddElement<uint32_t>(Material::VT_ORM, Orm, 0);
  }
  void add_Normal(uint32_t Normal) {
    fbb_.AddElement<uint32_t>(Material::VT_NORMAL, Normal, 0);
  }
  void add_Emissive(uint32_t Emissive) {
    fbb_.AddElement<uint32_t>(Material::VT_EMISSIVE, Emissive, 0);
  }
  void add_UserData(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> UserData) {
    fbb_.AddOffset(Material::VT_USERDATA, UserData);
  }
  void add_Parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<asdx::res::MaterialParameter>>> Parameters) {
    fbb_.AddOffset(Material::VT_PARAMETERS, Parameters);
  }
  void add_Buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer) {
    fbb_.AddOffset(Material::VT_BUFFER, Buffer);
  }
  void add_HasAlpha(bool HasAlpha) {
    fbb_.AddElement<uint8_t>(Material::VT_HASALPHA, static_cast<uint8_t>(HasAlpha), 0);
  }
  void add_Transparent(bool Transparent) {
    fbb_.AddElement<uint8_t>(Material::VT_TRANSPARENT, static_cast<uint8_t>(Transparent), 0);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    uint32_t BaseColor = 0,
    uint32_t Orm = 0,
    uint32_t Normal = 0,
    uint32_t Emissive = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> UserData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<asdx::res::MaterialParameter>>> Parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer = 0,
    bool HasAlpha = false,
    bool Transparent = false) {
  MaterialBuilder builder_(_fbb);
  builder_.add_Buffer(Buffer);
  builder_.add_Parameters(Parameters);
  builder_.add_UserData(UserData);
  builder_.add_Emissive(Emissive);
  builder_.add_Normal(Normal);
  builder_.add_Orm(Orm);
  builder_.add_BaseColor(BaseColor);
  builder_.add_Name(Name);
  builder_.add_Transparent(Transparent);
  builder_.add_HasAlpha(HasAlpha);
  return builder_.Finish();
}

inline flatbuffers::Offset<Material> CreateMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    uint32_t BaseColor = 0,
    uint32_t Orm = 0,
    uint32_t Normal = 0,
    uint32_t Emissive = 0,
    const std::vector<uint32_t> *UserData = nullptr,
    const std::vector<flatbuffers::Offset<asdx::res::MaterialParameter>> *Parameters = nullptr,
    const std::vector<uint8_t> *Buffer = nullptr,
    bool HasAlpha = false,
    bool Transparent = false) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto UserData__ = UserData ? _fbb.CreateVector<uint32_t>(*UserData) : 0;
  auto Parameters__ = Parameters ? _fbb.CreateVector<flatbuffers::Offset<asdx::res::MaterialParameter>>(*Parameters) : 0;
  auto Buffer__ = Buffer ? _fbb.CreateVector<uint8_t>(*Buffer) : 0;
  return asdx::res::CreateMaterial(
      _fbb,
      Name__,
      BaseColor,
      Orm,
      Normal,
      Emissive,
      UserData__,
      Parameters__,
      Buffer__,
      HasAlpha,
      Transparent);
}

struct MaterialSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MATERIALS = 6,
    VT_TEXTURES = 8
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<asdx::res::Material>> *Materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<asdx::res::Material>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *Textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TEXTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(Materials()) &&
           verifier.VerifyVectorOfTables(Materials()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(Textures()) &&
           verifier.VerifyVectorOfStrings(Textures()) &&
           verifier.EndTable();
  }
};

struct MaterialSetBuilder {
  typedef MaterialSet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(MaterialSet::VT_NAME, Name);
  }
  void add_Materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<asdx::res::Material>>> Materials) {
    fbb_.AddOffset(MaterialSet::VT_MATERIALS, Materials);
  }
  void add_Textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> Textures) {
    fbb_.AddOffset(MaterialSet::VT_TEXTURES, Textures);
  }
  explicit MaterialSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialSet> CreateMaterialSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<asdx::res::Material>>> Materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> Textures = 0) {
  MaterialSetBuilder builder_(_fbb);
  builder_.add_Textures(Textures);
  builder_.add_Materials(Materials);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialSet> CreateMaterialSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const std::vector<flatbuffers::Offset<asdx::res::Material>> *Materials = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *Textures = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Materials__ = Materials ? _fbb.CreateVector<flatbuffers::Offset<asdx::res::Material>>(*Materials) : 0;
  auto Textures__ = Textures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*Textures) : 0;
  return asdx::res::CreateMaterialSet(
      _fbb,
      Name__,
      Materials__,
      Textures__);
}

inline const asdx::res::MaterialSet *GetMaterialSet(const void *buf) {
  return flatbuffers::GetRoot<asdx::res::MaterialSet>(buf);
}

inline const asdx::res::MaterialSet *GetSizePrefixedMaterialSet(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<asdx::res::MaterialSet>(buf);
}

inline bool VerifyMaterialSetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<asdx::res::MaterialSet>(nullptr);
}

inline bool VerifySizePrefixedMaterialSetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<asdx::res::MaterialSet>(nullptr);
}

inline void FinishMaterialSetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<asdx::res::MaterialSet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMaterialSetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<asdx::res::MaterialSet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace res
}  // namespace asdx

#endif  // FLATBUFFERS_GENERATED_MATERIAL_ASDX_RES_H_
