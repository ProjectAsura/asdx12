//-----------------------------------------------------------------------------
// File : asdxList.h
// Desc : Double-Linked List.
// Copyright(c) Project Asura. All right reserved.
//-----------------------------------------------------------------------------
#pragma once


namespace asdx {

///////////////////////////////////////////////////////////////////////////////
// ListNode class
///////////////////////////////////////////////////////////////////////////////
template<typename T>
class ListNode
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    ListNode()
    : m_Next(nullptr)
    , m_Prev(nullptr)
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------
    //! @brief      次のノードを取得します.
    //-------------------------------------------------------------------------
    T* GetNext() const 
    { return m_Next; }

    //-------------------------------------------------------------------------
    //! @brief      前のノードを取得します.
    //-------------------------------------------------------------------------
    T* GetPrev() const
    { return m_Prev; }

    //-------------------------------------------------------------------------
    //! @brief      次のノードがあるかチェックします.
    //-------------------------------------------------------------------------
    bool HasNext() const
    { return m_Next != nullptr; }

    //-------------------------------------------------------------------------
    //! @brief      前のノードがあるかチェックします.
    //-------------------------------------------------------------------------
    bool HasPrev() const
    { return m_Prev != nullptr; }

    //-------------------------------------------------------------------------
    //! @brief      リンクを設定します.
    //-------------------------------------------------------------------------
    static void Link(T* lhs, T* rhs)
    {
        if (lhs == nullptr || rhs == nullptr)
        { return; }

        lhs->m_Next = rhs;
        rhs->m_Prev = lhs;
    }

    //-------------------------------------------------------------------------
    //! @brief      リンクを解除します.
    //-------------------------------------------------------------------------
    static void Unlink(T* node)
    {
        if (node == nullptr)
        { return; }

        auto prev = node->m_Prev;
        auto next = node->m_Next;

        if (prev != nullptr)
        { prev->m_Next = next; }

        if (next != nullptr)
        { next->m_Prev = prev; }

        node->m_Prev = nullptr;
        node->m_Next = nullptr;
    }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    T*  m_Next = nullptr;
    T*  m_Prev = nullptr;

    //=========================================================================
    // private methods.
    //=========================================================================
    /* NOTHING */
};

///////////////////////////////////////////////////////////////////////////////
// List class
///////////////////////////////////////////////////////////////////////////////
template<typename T>
class List
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    List()
    : m_Head(nullptr)
    , m_Tail(nullptr)
    , m_Count(0)
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------
    //! @brief      リストを破棄します.
    //-------------------------------------------------------------------------
    void Clear()
    {
        auto itr = m_Head;
        while(itr != nullptr)
        {
            auto node = itr;
            ListNode<T>::Unlink(node);

            if (!itr->HasNext())
            { break; }

            itr = itr->GetNext();
        }

        m_Head = nullptr;
        m_Tail = nullptr;

        m_Count = 0;
    }

    //-------------------------------------------------------------------------
    //! @brief      先頭に追加します.
    //-------------------------------------------------------------------------
    void PushFront(T* node)
    {
        if (node == nullptr)
        { return; }

        // 継承チェック.
        assert(static_cast<ListNode<T>*>(node) != nullptr);

        if (m_Head == nullptr)
        {
            m_Head = node;
            m_Tail = node;
        }
        else
        {
            ListNode<T>::Link(node, m_Head);
            m_Head = node;
        }
        m_Count++;
    }

    //-------------------------------------------------------------------------
    //! @brief      末尾に追加します.
    //-------------------------------------------------------------------------
    void PushBack(T* node)
    {
        if (node == nullptr)
        { return; }

        // 継承チェック.
        assert(static_cast<ListNode<T>*>(node) != nullptr);

        if (m_Head == nullptr)
        {
            m_Head = node;
            m_Tail = node;
        }
        else
        {
            ListNode<T>::Link(m_Tail, node);
            m_Tail = node;
        }
        m_Count++;
    }

    //-------------------------------------------------------------------------
    //! @brief      先頭要素を取り出します.
    //-------------------------------------------------------------------------
    T* PopFront()
    {
        if (m_Head == nullptr)
        { return nullptr; }

        auto head = m_Head;
        auto next = m_Head->GetNext();
        ListNode<T>::Unlink(head);
        m_Head = next;
        m_Count--;
        return head;
    }

    //-------------------------------------------------------------------------
    //! @brief      末尾要素を取り出します.
    //-------------------------------------------------------------------------
    T* PopBack()
    {
        if (m_Tail == nullptr)
        { return nullptr; }

        auto tail = m_Tail;
        auto prev = m_Tail->GetPrev();
        ListNode<T>::Unlink(tail);
        m_Tail = prev;
        m_Count--;
        return tail;
    }

    //-------------------------------------------------------------------------
    //! @brief      指定ノードをリストから削除します.
    //-------------------------------------------------------------------------
    void Remove(T* node)
    {
        if (node == nullptr)
        { return; }

        ListNode<T>::Unlink(node);
        m_Count--;
    }

    //-------------------------------------------------------------------------
    //! @brief      指定ノードが含まれるかチェックします.
    //-------------------------------------------------------------------------
    bool Contains(const T* node) const
    {
        if (node == nullptr)
        { return false; }

        auto itr = m_Head;
        while(itr != nullptr)
        {
            if (itr == node)
            { return true; }

            if (!itr->HasNext())
            { break; }

            itr = itr->GetNext();
        }

        return false;
    }

    //-------------------------------------------------------------------------
    //! @brief      先頭ノードを取得します.
    //-------------------------------------------------------------------------
    T* GetHead() const
    { return m_Head; }

    //-------------------------------------------------------------------------
    //! @brief      末尾ノードを取得します.
    //-------------------------------------------------------------------------
    T* GetTail() const
    { return m_Tail; }

    //-------------------------------------------------------------------------
    //! @brief      ノード数を取得します.
    //-------------------------------------------------------------------------
    size_t GetCount() const
    { return m_Count; }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    T*      m_Head  = nullptr;
    T*      m_Tail  = nullptr;
    size_t  m_Count = 0;

    //=========================================================================
    // private methods.
    //=========================================================================
    /* NOTHING */
};

} // namespace asdx
