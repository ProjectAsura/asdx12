//-------------------------------------------------------------------------------------------------
// File : asdxRandom.cpp
// Desc : Random Number Generater Moudle
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
// Includes
//-------------------------------------------------------------------------------------------------
#include <core/asdxMath.h>


namespace asdx {

///////////////////////////////////////////////////////////////////////////////////////////////////
// XorShift class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      コンストラクタです.
//-------------------------------------------------------------------------------------------------
XorShift::XorShift( int seed )
{ SetSeed( seed ); }

//-------------------------------------------------------------------------------------------------
//      コピーコンストラクタです.
//-------------------------------------------------------------------------------------------------
XorShift::XorShift( const XorShift& random )
{
    m_X = random.m_X;
    m_Y = random.m_Y;
    m_Z = random.m_Z;
    m_W = random.m_W;
}

//-------------------------------------------------------------------------------------------------
//      デストラクタです.
//-------------------------------------------------------------------------------------------------
XorShift::~XorShift()
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      ランダム種を設定します.
//-------------------------------------------------------------------------------------------------
void XorShift::SetSeed( int seed )
{
    m_X = 123456789;
    m_Y = 362436069;
    m_Z = 521288629;
    m_W = ( seed <= 0 ) ? 88675123 : seed;
}

//-------------------------------------------------------------------------------------------------
//      乱数をuint32_t型として取得します.
//-------------------------------------------------------------------------------------------------
uint32_t XorShift::GetAsU32()
{
    auto t = m_X ^ ( m_X << 11 );
    m_X = m_Y;
    m_Y = m_Z;
    m_Z = m_W;
    m_W = ( m_W ^ ( m_W >> 19 ) ) ^ ( t ^ ( t >> 8 ) );
    return m_W;
}

//-------------------------------------------------------------------------------------------------
//      乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int XorShift::GetAsS32()
{
    int x = GetAsU32() & 0x7fffffff;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int XorShift::GetAsS32( int a )
{
    // 符号ビット切り捨て.
    int x = GetAsU32() & 0x7fffffff;
    x %= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲で乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int XorShift::GetAsS32( int a, int b )
{
    int x = GetAsU32() & 0x7fffffff;
    x %= ( b - a );
    x += a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float XorShift::GetAsF32()
{ return static_cast<float>( GetAsU32() ) / UINT32_MAX; }

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float XorShift::GetAsF32( float a )
{
    auto x = GetAsF32();
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲の乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float XorShift::GetAsF32( float a, float b )
{
    auto x = GetAsF32();
    x *= ( b - a );
    x += a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double XorShift::GetAsF64()
{ return static_cast<double>( GetAsU32() ) / UINT32_MAX; }

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double XorShift::GetAsF64( double a )
{
    auto x = GetAsF64();
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲で乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double XorShift::GetAsF64( double a, double b )
{
    auto x = GetAsF64();
    x *= ( b - a );
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      代入演算子です.
//-------------------------------------------------------------------------------------------------
XorShift& XorShift::operator = ( const XorShift& random )
{
    m_X = random.m_X;
    m_Y = random.m_Y;
    m_Z = random.m_Z;
    m_W = random.m_W;
    return (*this);
}

//-------------------------------------------------------------------------------------------------
//      等価演算子です.
//-------------------------------------------------------------------------------------------------
bool XorShift::operator == ( const XorShift& random ) const
{ return ( this == &random ); }

//-------------------------------------------------------------------------------------------------
//      非等価演算子です.
//-------------------------------------------------------------------------------------------------
bool XorShift::operator != ( const XorShift& random ) const
{ return ( this != &random ); }


///////////////////////////////////////////////////////////////////////////////////////////////////
// PCG class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      コンストラクタです.
//-------------------------------------------------------------------------------------------------
PCG::PCG( uint64_t seed )
{ SetSeed( seed ); }

//-------------------------------------------------------------------------------------------------
//      コピーコンストラクタです.
//-------------------------------------------------------------------------------------------------
PCG::PCG( const PCG& random )
: m_State(random.m_State)
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      デストラクタです.
//-------------------------------------------------------------------------------------------------
PCG::~PCG()
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      ランダム種を設定します.
//-------------------------------------------------------------------------------------------------
void PCG::SetSeed( uint64_t seed )
{
    m_State = seed + s_Increment;
    GetAsU32();
}

//-------------------------------------------------------------------------------------------------
//      乱数をuint32_t型として取得します.
//-------------------------------------------------------------------------------------------------
uint32_t PCG::GetAsU32()
{
    uint64_t x = m_State;
    uint32_t count = uint32_t(x >> 59);

    m_State = x * s_Multiplier + s_Increment;
    x ^= x >> 18;
    return Rotate(uint32_t(x >> 27), count);
}

//-------------------------------------------------------------------------------------------------
//      乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int PCG::GetAsS32()
{
    int x = GetAsU32() & 0x7fffffff;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int PCG::GetAsS32( int a )
{
    // 符号ビット切り捨て.
    int x = GetAsU32() & 0x7fffffff;
    x %= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲で乱数をint型として取得します.
//-------------------------------------------------------------------------------------------------
int PCG::GetAsS32( int a, int b )
{
    int x = GetAsU32() & 0x7fffffff;
    x %= ( b - a );
    x += a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float PCG::GetAsF32()
{ return static_cast<float>( GetAsU32() ) / UINT32_MAX; }

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float PCG::GetAsF32( float a )
{
    auto x = GetAsF32();
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲の乱数をfloat型として取得します.
//-------------------------------------------------------------------------------------------------
float PCG::GetAsF32( float a, float b )
{
    auto x = GetAsF32();
    x *= ( b - a );
    x += a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double PCG::GetAsF64()
{ return static_cast<double>( GetAsU32() ) / UINT32_MAX; }

//-------------------------------------------------------------------------------------------------
//      指定された値範囲までの乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double PCG::GetAsF64( double a )
{
    auto x = GetAsF64();
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      指定された値範囲で乱数をdouble型として取得します.
//-------------------------------------------------------------------------------------------------
double PCG::GetAsF64( double a, double b )
{
    auto x = GetAsF64();
    x *= ( b - a );
    x *= a;
    return x;
}

//-------------------------------------------------------------------------------------------------
//      代入演算子です.
//-------------------------------------------------------------------------------------------------
PCG& PCG::operator = ( const PCG& random )
{
    m_State = random.m_State;
    return (*this);
}

//-------------------------------------------------------------------------------------------------
//      等価演算子です.
//-------------------------------------------------------------------------------------------------
bool PCG::operator == ( const PCG& random ) const
{ return ( this == &random ); }

//-------------------------------------------------------------------------------------------------
//      非等価演算子です.
//-------------------------------------------------------------------------------------------------
bool PCG::operator != ( const PCG& random ) const
{ return  ( this != &random ); }

//-----------------------------------------------------------------------------
//      ビット回転処理を行います.
//-----------------------------------------------------------------------------
uint32_t PCG::Rotate(uint32_t x, uint32_t r)
{ return x >> r | x << ((~r + 1u) & 31); }

} // namespace asdx
