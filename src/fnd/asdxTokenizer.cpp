//-----------------------------------------------------------------------------
// File : asdxTokenizer.cpp
// Desc : Tokenizer Module.
// Copyright(c) Project Asura All right reserved.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <fnd/asdxTokenizer.h>
#include <new>


namespace asdx {

///////////////////////////////////////////////////////////////////////////////
// Tokenizer class
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//      コンストラクタです.
//-----------------------------------------------------------------------------
Tokenizer::Tokenizer()
: m_pBuffer     (nullptr)
, m_pPtr        (nullptr)
, m_pToken      (nullptr)
, m_Separator   ()
, m_CutOff      ()
, m_BufferSize  (0)
{ /* DO_NOTHING */ }

//-----------------------------------------------------------------------------
//      デストラクタです.
//-----------------------------------------------------------------------------
Tokenizer::~Tokenizer()
{ Term(); }

//-----------------------------------------------------------------------------
//      初期化処理を行います.
//-----------------------------------------------------------------------------
bool Tokenizer::Init(uint32_t size)
{
    m_pToken = new(std::nothrow) char[size];
    if (m_pToken == nullptr)
    { return false; }

    memset(m_pToken, 0, sizeof(char) * size);

    return true;
}

//-----------------------------------------------------------------------------
//      終了処理を行います.
//-----------------------------------------------------------------------------
void Tokenizer::Term()
{
    if (m_pToken != nullptr)
    {
        delete [] m_pToken;
        m_pToken = nullptr;
    }

    m_Separator .clear();
    m_CutOff    .clear();

    m_pPtr          = nullptr;
    m_pBuffer       = nullptr;
    m_BufferSize    = 0;
}

//-----------------------------------------------------------------------------
//      区切り文字を設定します.
//-----------------------------------------------------------------------------
void Tokenizer::SetSeparator(const char *separator)
{ m_Separator = std::string(separator); }

//-----------------------------------------------------------------------------
//      切り出し文字を設定します.
//-----------------------------------------------------------------------------
void Tokenizer::SetCutOff(const char *cutoff)
{ m_CutOff = std::string(cutoff); }

//-----------------------------------------------------------------------------
//      バッファを設定します.
//-----------------------------------------------------------------------------
void Tokenizer::SetBuffer(char *buffer, size_t bufferSize)
{
    m_pBuffer = buffer;
    m_pPtr    = buffer;
    m_BufferSize = bufferSize;

    Next();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得します.
//-----------------------------------------------------------------------------
void Tokenizer::Next()
{
    auto sizeP = size_t(m_pPtr - m_pBuffer);
    if (sizeP >= m_BufferSize)
    { return; }

    auto p = m_pPtr;
    auto q = m_pToken;

    // 区切り文字はスキップする
    while ((*p) != '\0' && strchr(m_Separator.c_str(), *p))
    { p++; }

    // 切り出し文字とヒットするか判定
    if (strchr(m_CutOff.c_str(), *p))
    {
        //切り出し文字とヒットしたら，単体トークンとする
        (*(q++)) = (*(p++));
    }
    else
    {
        //区切り文字または切り出し文字以外ならトークンとする
        std::string split = m_Separator + m_CutOff;
        while (*p != '\0' && !strchr(split.c_str(), *p))
        {
            (*(q++)) = (*(p++));
        }
    }

    //抜き出した分だけバッファを進める
    m_pPtr = p;

    //文字列として返すためにNULL終端文字を加える
    *q = '\0';
}

//-----------------------------------------------------------------------------
//      指定した文字列が出てくるまでトークンを読み飛ばします.
//-----------------------------------------------------------------------------
void Tokenizer::SkipTo(const char* text)
{
    while(!IsEnd())
    {
        auto ret = Contain(text);
        if (ret != nullptr)
        {
            Next();
            break;
        }

        Next();
    }
}

//-----------------------------------------------------------------------------
//      改行コードが出てくるまで読み飛ばします.
//-----------------------------------------------------------------------------
void Tokenizer::SkipLine()
{
    auto p = m_pPtr;
    auto q = m_pToken;

    // 区切り文字はスキップする
    while ((*p) != '\0' && strchr(" \t", *p))
    { p++; }

    auto pos = strstr(p, "\n");
    if (pos != nullptr)
    {
        m_pPtr = pos;
        auto size = pos - p;
        memcpy(m_pToken, p, size);
        m_pToken[size] = '\0';
    }
}

//-----------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-----------------------------------------------------------------------------
bool Tokenizer::Compare(const char *token) const
{ return (strcmp(m_pToken, token) == 0); }

//-----------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-----------------------------------------------------------------------------
bool Tokenizer::CompareAsLower(const char *token) const
{ return (_stricmp(m_pToken, token) == 0); }

//-----------------------------------------------------------------------------
//      指定された文字列と部分一致するかどうかチェックします.
//-----------------------------------------------------------------------------
char* Tokenizer::Contain(const char* token) const
{ return strstr(m_pToken, token); }

//-----------------------------------------------------------------------------
//      最後かどうかチェックします.
//-----------------------------------------------------------------------------
bool Tokenizer::IsEnd() const
{
    if (*m_pPtr == '\0' || m_pPtr == nullptr)
    { return true; }

    auto sizeP = size_t(m_pPtr - m_pBuffer);
    return (sizeP >= m_BufferSize);
}

//-----------------------------------------------------------------------------
//      トークンが有効かどうかチェックします.
//-----------------------------------------------------------------------------
bool Tokenizer::IsValidToken() const
{ return (*m_pToken != '\0' && m_pToken != nullptr); }

//-----------------------------------------------------------------------------
//      バッファを取得します.
//-----------------------------------------------------------------------------
char* Tokenizer::GetBuffer() const
{ return m_pBuffer; }

//-----------------------------------------------------------------------------
//      現在のポインタを取得します.
//-----------------------------------------------------------------------------
char* Tokenizer::GetPtr() const
{ return m_pPtr; }

//-----------------------------------------------------------------------------
//      char型としてトークンを取得します.
//-----------------------------------------------------------------------------
char* Tokenizer::GetAsChar() const
{ return m_pToken; }

//-----------------------------------------------------------------------------
//      double型としてトークンを取得します.
//-----------------------------------------------------------------------------
double Tokenizer::GetAsDouble() const
{ return atof(m_pToken); }

//-----------------------------------------------------------------------------
//      float型としてトークンを取得します.
//-----------------------------------------------------------------------------
float Tokenizer::GetAsFloat() const
{ return static_cast<float>(atof(m_pToken)); }

//-----------------------------------------------------------------------------
//      int型としてトークンを取得します.
//-----------------------------------------------------------------------------
int Tokenizer::GetAsInt() const
{ return atoi(m_pToken); }

//-----------------------------------------------------------------------------
//      bool型としてトークンを取得します.
//-----------------------------------------------------------------------------
bool Tokenizer::GetAsBool() const
{
    if (_stricmp(m_pToken, "TRUE") == 0)
    { return true; }
    else if (_stricmp(m_pToken, "FALSE") == 0)
    { return false; }

    return false;
}

//-----------------------------------------------------------------------------
//      uint32_t型としてトークンを取得します.
//-----------------------------------------------------------------------------
uint32_t Tokenizer::GetAsUint() const
{ return strtoul(m_pToken, nullptr, 0); }

//-----------------------------------------------------------------------------
//      次のトークンを取得して，char型として返却します.
//-----------------------------------------------------------------------------
char* Tokenizer::NextAsChar()
{
    Next();
    return GetAsChar();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得して，double型として返却します.
//-----------------------------------------------------------------------------
double Tokenizer::NextAsDouble()
{
    Next();
    return GetAsDouble();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得して，float型として返却します.
//-----------------------------------------------------------------------------
float Tokenizer::NextAsFloat()
{
    Next();
    return GetAsFloat();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得して，int型として返却します.
//-----------------------------------------------------------------------------
int Tokenizer::NextAsInt()
{
    Next();
    return GetAsInt();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得して, bool型として返却します.
//-----------------------------------------------------------------------------
bool Tokenizer::NextAsBool()
{
    Next();
    return GetAsBool();
}

//-----------------------------------------------------------------------------
//      次のトークンを取得して, uint32_t型として返却します.
//-----------------------------------------------------------------------------
uint32_t Tokenizer::NextAsUint()
{
    Next();
    return GetAsUint();
}

} // namespace asdx
